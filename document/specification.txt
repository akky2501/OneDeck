
例
///////////////////////////////////////////////////////////////////////////////////////////////////////////////


// カードの束の定義
Cards 山札 初期値 Fulldeck-{'JK1 'JK2}
Cards 手札A
Cards 手札B
Cards 手札C
Cards 手札D
Cards 場札
Cards 捨山

// アクターの定義
Actor ゲームマスター ゲーム51(A, B, C, D, 山札)
Actor A プレイヤー(手札A, 山札, 場札, 捨山, ゲームマスター)
Actor B プレイヤー(手札B, 山札, 場札, 捨山, ゲームマスター)
Actor C プレイヤー(手札C, 山札, 場札, 捨山, ゲームマスター)
Actor D プレイヤー(手札D, 山札, 場札, 捨山, ゲームマスター)

// エントリポイント
Entry [ゲームマスター]の[準備]を行う。

// プレイヤーの役割の定義
Role プレイヤー (自分の手札, 山札, 場札, 捨山, ゲームマスター) {
  準備 {
      配布: [山札]から['5]枚を[自分の手札]へ追加する。
  }

  1巡目 {
    When [自分の手札]は[?P]を含む && [場札]は[?Q]を含む -> 交換(?P,?Q): [自分の手札]の[?P]と[場札]の[?Q]を交換する。
  }

  2巡目以降 {
    When [自分の手札]は[?P]を含む && [場札]は[?Q]を含む -> 交換(?P,?Q): [自分の手札]の[?P]と[場札]の[?Q]を交換する。
    取り換え: [自分の手札]と[場札]を交換する。
    破棄: [場札]を[捨山]へ移動する、[山札]から['5]枚を[場札]へ追加する。
    パス: 何もしない。
  }

  2巡目以降で場を流した時 {
    When [自分の手札]は[?P]を含む && [場札]は[?Q]を含む -> 交換(?P,?Q): [自分の手札]の[?P]と[場札]の[?Q]を交換する。
    取り換え: [自分の手札]と[場札]を交換する。
    パス: 何もしない。
  }

  コール選択 {
    コールする: [ゲームマスター]の[結果の評価]を行う。
    コールしない: 何もしない。
  }
}

// ゲームマスターの振る舞いの定義
Role ゲーム51 (A, B, C, D, 山札){
  準備 {
    _: [山札]をシャッフルする、
       [A]の[準備]を行う、
       [B]の[準備]を行う、
       [C]の[準備]を行う、
       [D]の[準備]を行う、
       [自分]の[1巡目]を行う。 //「自分」は特殊なキーワード
  }

  1巡目 {
    _: [A]の[1巡目]を行う、
       [B]の[1巡目]を行う、
       [C]の[1巡目]を行う、
       [D]の[1巡目]を行う、
       [自分]の[2巡目以降]を行う。
  }

  2巡目以降 {
    _: [A]の[2巡目以降]を行う、
       [A]が[破棄]をしたならば、[[A]の[2巡目以降で場を流した時]を行う]、
       [A]の[コール選択]を行う、
       [B]の[2巡目以降]を行う、
       [B]が[破棄]をしたならば、[[B]の[2巡目以降で場を流した時]を行う]、
       [B]の[コール選択]を行う、
       [C]の[2巡目以降]を行う、
       [C]が[破棄]をしたならば、[[C]の[2巡目以降で場を流した時]を行う]、
       [C]の[コール選択]を行う、
       [D]の[2巡目以降]を行う、
       [D]が[破棄]をしたならば、[[D]の[2巡目以降で場を流した時]を行う]、
       [D]の[コール選択]を行う、
       [自分]の[2巡目以降]を行う。
  }

  結果の評価 {
    _: 終了する。
  }
}



///////////////////////////////////////////////////////////////////////////////////////////////////////////////







言語仕様

1行コメントは//
キーワード
Fulldeck
Cards
Actor
Entry
Role
When
Self 自分


// カードの集合(列)
カードの束は列(並び順がある)で管理される。
したがって、適切な箇所でシャッフルする必要がある。


// プログラムはアクターのコンテキストとそのコンテキストでの選択により記述される
// 選択は選択肢により記述され、選択肢が選ばれた時の動作が命令列によってあらわされる
// 選択肢は仮定を置くことができる
// 操作命令列は「操作命令、操作命令、... 操作命令。」で表され、先頭から順に実行される

// 選択
// TODO: 「してもよい」と「しなくてはならない」の区別
// Must とか ! みたいなキーワードをchioceラベルの先頭につける
// Mustな選択肢が2つ以上あるときはエラー
// 選べる選択肢が一つもないときはエラー
// 選択肢をユーザーにすべて提示(組み合わせ爆発は考えてない)



// 操作命令(副作用のある計算)
・なにもしない
    スキップ命令

・終了する
    ゲームを終了する
    オブジェクト、アクターの状態を出力してインタプリタを終了する

・[X]をシャッフルする
    Xはカード束
    カード束の並びをランダムにする

・[X]を逆順にする
    Xはカード束
    カード束の並びを逆順にする

・[X]の[P]を[Y]へ追加する(、なければ～)
    XとYはカード束
    Pはカード
    カード束Xにある特定のカードPをカード束Yの末尾に追加する
    XにPが含まれていなければエラーを出す(なければ～があれば命令実行)
// [X]の[P]と[Y]の[Q]を交換する <=> [X]の[P]を[Y]へ移動する、[Y]の[Q]を[X]へ移動する

・[X]の[n]枚を[Y]へ追加する(、足りなければ～)
    XとYはカード束
    nは正整数
    カード束Xの先頭のn枚をカード束Yの末尾に追加する
    Xにn枚のカードがなかったらエラー　(足りなければ～があったら命令実行)

・[X]を[Y]へ移動する
    XとYはカード束
    カード束Xをすべて、カード束Yの末尾に追加する

・[X]と[Y]を交換する
    XとYはカード束
    カード束Xとカード束Yを交換する

・[A]の[K]を行う
    Aはアクター
    Kはコンテキスト
    アクターAのコンテキストCを行う。(選択肢の選択はユーザーが行う)

・[A]が[C]をしたならば～、(、そうでないならば～) ()内は省略可、省略されたときは(そうでないならば、なにもしない)になる
    Aはアクター
    Cは選択肢ラベル
    Aの行った直前の行動により動作を選択する。ただし動作は1命令。

...たぶんもっと増える


// 仮定を用いてパラメトリックなchoiceを生成できる
// 述語
仮定の中で使える述語は以下の組み合わせ(たぶん一階述語論理)
// 共通
?P は変数(個体)
(述語) 部分述語
&& and かつ
|| or または
~ not 否定 (これ大丈夫か？)

// カードに対する述語
[X]は[P]を含む (TODO: Xが変数の時はどうする？)
[P]は[Q]である
[P]のスートが[S]である
[P]の数字が[n]である

// TODO: カード束に対する述語(カード束の具体化は組み合わせ爆発するので制限が必要かも)
// TODO: アクターに対する述語

...たぶんもっと増える



// EBNF
Program      ::= (DeclCards | DeclActor | DeclEntry | DeclRole)*

DeclCard     ::= 'Cards' NAME ['初期値' '(' DeclDeck ')']

DeclDeck     ::= 'Fulldeck'
              |  '{' CardSeq '}'
              |  'Fulldeck' '-' '{' CardSeq '}'

CardSeq      ::= CARD+

DeclActor    ::= 'Actor' NAME RoleName

DeclEntry    ::= 'Entry' Action

DeclRole     ::= 'Role' RoleName '{' Situation+ '}'

RoleName     ::= NAME ['(' ObjSeq ')']

ObjSeq       ::= NAME (',' NAME)*

Situation    ::= NAME '{' Choice+ '}'

Choice       ::= ['When' Predicate '->'] ['Must'] ChoiceLabel ':' Action

ChoiceLabel  ::= NAME ['(' VarSeq ')']

ObjSeq       ::= VarOrName (',' VarOrName)*

VarOrName    ::= NAME | VAR

Action       ::= (PrimitiveAction '、')* PrimAction '。'

PrimAction   ::= プリミティブな操作命令

Predicate    ::= 述語の構成式定義(いつもの算術式)

